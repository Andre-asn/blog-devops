name: CI/CD Pipeline - Droplet 1

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    
    services:
      mongodb:
        image: mongo:7.0
        ports:
          - 27017:27017
        options: >-
          --health-cmd "mongosh --eval 'db.runCommand({ ping: 1 })'"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'
      
      - name: Cache pip dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          echo "Installed packages:"
          pip list | grep -E "Flask|pymongo|pytest|gunicorn|prometheus"
      
      - name: Wait for MongoDB
        run: |
          echo "Waiting for MongoDB to be ready..."
          python3 << 'EOF'
          import time
          from pymongo import MongoClient
          from pymongo.errors import ConnectionFailure

          for i in range(30):
              try:
                  client = MongoClient("mongodb://localhost:27017/", serverSelectionTimeoutMS=2000)
                  client.admin.command('ping')
                  print("‚úÖ MongoDB is ready")
                  exit(0)
              except ConnectionFailure:
                  print(f"Waiting... ({i+1}/30)")
                  time.sleep(2)
          
          print("‚ùå MongoDB failed to become ready")
          exit(1)
          EOF
      
      - name: Run tests
        env:
          MONGO_URI: mongodb://localhost:27017/
          SECRET_KEY: test-secret-key-for-ci-${{ github.run_number }}
          FLASK_ENV: testing
        run: |
          echo "Running pytest with coverage..."
          pytest -v \
            --cov=. \
            --cov-report=xml \
            --cov-report=html \
            --cov-report=term \
            --tb=short
          
          echo ""
          echo "=== Test Summary ==="
          echo "‚úÖ Tests completed"
      
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          files: ./coverage.xml
          fail_ci_if_error: false
          verbose: true
      
      - name: Upload coverage reports as artifact
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: coverage-report
          path: htmlcov/
          retention-days: 30
      
      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results
          path: |
            test-results.xml
            htmlcov/
          retention-days: 30

  generate-documentation:
    name: Generate Pyreverse Documentation
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      
      - name: Install Pylint and Graphviz
        run: |
          python -m pip install --upgrade pip
          pip install pylint
          sudo apt-get update
          sudo apt-get install -y graphviz
          
          echo "Pylint version:"
          pylint --version
          
          echo ""
          echo "Graphviz version:"
          dot -V
      
      - name: Create documentation directory
        run: |
          mkdir -p documentations/actions-doc
          echo "‚úÖ Created documentations/actions-doc directory"
      
      - name: Find Python files
        id: find-python
        run: |
          echo "=== Finding Python files ==="
          
          PYTHON_FILES=$(find . -name "*.py" \
            -not -path "./venv/*" \
            -not -path "./.venv/*" \
            -not -path "./__pycache__/*" \
            -not -path "./tests/*" \
            -not -path "./.git/*" \
            -not -path "./htmlcov/*" \
            -not -name "conftest.py" \
            -not -name "test_*.py" \
            | tr '\n' ' ')
          
          echo "Python files found:"
          echo "$PYTHON_FILES" | tr ' ' '\n' | grep -v "^$" | sed 's/^/  ‚Ä¢ /'
          
          echo "python_files=$PYTHON_FILES" >> $GITHUB_OUTPUT
      
      - name: Generate Pyreverse UML diagrams
        run: |
          echo "=== Running Pyreverse ==="
          
          PYTHON_FILES="${{ steps.find-python.outputs.python_files }}"
          
          if [ -z "$PYTHON_FILES" ]; then
            echo "‚ö†Ô∏è No Python files found to analyze"
            exit 0
          fi
          
          # Generate class and package diagrams
          echo "Generating UML diagrams..."
          pyreverse -o dot -p blog_app $PYTHON_FILES -d documentations/actions-doc 2>/dev/null || true
          
          echo ""
          echo "Generated .dot files:"
          ls -la documentations/actions-doc/*.dot 2>/dev/null || echo "  No .dot files generated"
      
      - name: Convert to PNG and SVG
        run: |
          echo "=== Converting diagrams to PNG and SVG ==="
          
          for dotfile in documentations/actions-doc/*.dot; do
            if [ -f "$dotfile" ]; then
              basename=$(basename "$dotfile" .dot)
              echo "Converting $basename..."
              
              # Generate PNG
              dot -Tpng "$dotfile" -o "documentations/actions-doc/${basename}.png" && \
                echo "  ‚úÖ ${basename}.png" || echo "  ‚ö†Ô∏è Failed to generate ${basename}.png"
              
              # Generate SVG
              dot -Tsvg "$dotfile" -o "documentations/actions-doc/${basename}.svg" && \
                echo "  ‚úÖ ${basename}.svg" || echo "  ‚ö†Ô∏è Failed to generate ${basename}.svg"
            fi
          done
      
      - name: Generate Documentation README
        env:
          GITHUB_RUN_NUMBER: ${{ github.run_number }}
          GITHUB_SHA: ${{ github.sha }}
        run: |
          cat > documentations/actions-doc/README.md << 'READMEEOF'
          # GitHub Actions - Code Documentation

          This documentation is automatically generated by the GitHub Actions CI/CD pipeline using Pyreverse.

          ## Generated Files

          ### UML Diagrams

          | File | Description |
          |------|-------------|
          | classes_blog_app.dot | Class diagram in DOT format |
          | classes_blog_app.png | Class diagram as PNG image |
          | classes_blog_app.svg | Class diagram as SVG (scalable) |
          | packages_blog_app.dot | Package diagram in DOT format |
          | packages_blog_app.png | Package diagram as PNG image |
          | packages_blog_app.svg | Package diagram as SVG (scalable) |

          ### Class Diagram
          Shows the classes in the application, their attributes, methods, and relationships.

          ![Class Diagram](classes_blog_app.png)

          ### Package Diagram
          Shows the package/module structure and dependencies.

          ![Package Diagram](packages_blog_app.png)

          ## Generation Details

          - **Generated by**: GitHub Actions
          - **Tool**: Pyreverse (part of Pylint)
          - **Visualization**: Graphviz

          ## How to Regenerate

          These diagrams are automatically regenerated on each successful push to main branch.

          To manually regenerate:

          1. Install dependencies: pip install pylint
          2. Install Graphviz: sudo apt-get install graphviz
          3. Generate dot files: pyreverse -o dot -p blog_app *.py
          4. Convert to images: dot -Tpng classes_blog_app.dot -o classes_blog_app.png

          ## Last Updated
          READMEEOF
          
          echo "" >> documentations/actions-doc/README.md
          echo "**Timestamp**: $(date -u)" >> documentations/actions-doc/README.md
          echo "" >> documentations/actions-doc/README.md
          echo "**GitHub Run**: #${GITHUB_RUN_NUMBER}" >> documentations/actions-doc/README.md
          echo "" >> documentations/actions-doc/README.md
          echo "**Commit**: ${GITHUB_SHA}" >> documentations/actions-doc/README.md
      
      - name: List generated files
        run: |
          echo "=== Documentation Generated ==="
          echo "Contents of documentations/actions-doc:"
          ls -la documentations/actions-doc/ | sed 's/^/  /'
      
      - name: Upload documentation as artifact
        uses: actions/upload-artifact@v4
        with:
          name: pyreverse-documentation
          path: documentations/actions-doc/
          retention-days: 30
      
      - name: Commit and push documentation
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Pull latest changes to avoid conflicts
          git pull origin main --rebase || true
          
          # Add documentation files
          git add documentations/actions-doc/
          
          # Check if there are changes to commit
          if git diff --cached --quiet; then
            echo "‚ÑπÔ∏è No changes to documentation - skipping commit"
          else
            echo "Committing documentation changes..."
            git commit -m "docs(actions): Update Pyreverse UML documentation [Run #${{ github.run_number }}] [skip ci]"
            
            # Push changes
            echo "Pushing to repository..."
            git push origin main
            
            echo "‚úÖ Documentation committed and pushed successfully"
          fi

  deploy:
    name: Deploy to Droplet 1
    needs: [test, generate-documentation]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.DIGITALOCEAN_SSH_KEY }}
      
      - name: Add server to known hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.DIGITALOCEAN_HOST }} >> ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts
      
      - name: Test SSH connection
        env:
          HOST: ${{ secrets.DIGITALOCEAN_HOST }}
          USER: ${{ secrets.DIGITALOCEAN_USER }}
        run: |
          echo "Testing SSH connection to $HOST..."
          ssh -o ConnectTimeout=10 $USER@$HOST 'echo "‚úÖ SSH connection successful"'
      
      - name: Deploy to DigitalOcean Droplet 1
        env:
          HOST: ${{ secrets.DIGITALOCEAN_HOST }}
          USER: ${{ secrets.DIGITALOCEAN_USER }}
          APP_DIR: ${{ secrets.APP_DIRECTORY }}
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
          MONGO_URI: ${{ secrets.MONGO_URI }}
          DATABASE_NAME: ${{ secrets.DATABASE_NAME }}
          GITHUB_RUN: ${{ github.run_number }}
        run: |
          echo "=== Starting Deployment to Droplet 1 ==="
          echo "Host: $HOST"
          echo "User: $USER"
          echo "App Directory: $APP_DIR"
          echo "GitHub Run: #$GITHUB_RUN"
          echo ""
          
          ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 $USER@$HOST "bash -s" <<ENDSSH
          set -e
          
          echo "=== Deployment Started ==="
          echo "Timestamp: \$(date)"
          echo ""
          
          cd ${APP_DIR}
          echo "‚úÖ In directory: \$(pwd)"
          
          echo "Current branch: \$(git branch --show-current)"
          
          # Clean local repository
          echo ""
          echo "üßπ Cleaning local repository..."
          git reset --hard HEAD
          git clean -fd
          
          # Fetch latest from remote
          echo ""
          echo "üì• Fetching latest code from remote..."
          git fetch origin main
          
          # Force reset to match remote (handles divergent branches)
          echo ""
          echo "üîÑ Resetting to origin/main..."
          git reset --hard origin/main
          
          echo "Latest commit: \$(git log -1 --oneline)"
          
          echo ""
          echo "üêç Activating virtual environment..."
          if [ ! -d "venv" ]; then
              echo "‚ö†Ô∏è  Virtual environment not found, creating..."
              python3 -m venv venv
          fi
          source venv/bin/activate
          
          echo "Python: \$(which python3)"
          echo "Pip: \$(which pip)"
          
          echo ""
          echo "üì¶ Installing/updating dependencies..."
          pip install --upgrade pip
          pip install -r requirements.txt
          
          echo "Verifying critical packages:"
          pip show Flask pymongo gunicorn prometheus-client | grep -E "Name|Version" || true
          
          echo ""
          echo "‚öôÔ∏è  Updating environment variables..."
          echo "SECRET_KEY=${SECRET_KEY}" > .env
          echo "MONGO_URI=${MONGO_URI}" >> .env
          echo "DATABASE_NAME=${DATABASE_NAME}" >> .env
          echo "FLASK_ENV=production" >> .env
          echo "FLASK_DEBUG=False" >> .env
          chmod 600 .env
          echo "‚úÖ Environment file updated"
          
          echo ""
          echo "üìù Setting up logs directory..."
          mkdir -p logs
          chmod 755 logs
          echo "‚úÖ Logs directory ready"
          
          deactivate
          
          echo ""
          echo "üîç Pre-deployment checks..."
          
          if ! systemctl list-unit-files | grep -q "blog-app.service"; then
              echo "‚ùå blog-app.service not found"
              echo "Please run the setup script first"
              exit 1
          fi
          echo "‚úÖ Service file exists"
          
          if ! systemctl is-active --quiet mongod; then
              echo "‚ö†Ô∏è  MongoDB not running, attempting to start..."
              sudo systemctl start mongod
              sleep 3
          fi
          
          if systemctl is-active --quiet mongod; then
              echo "‚úÖ MongoDB is running"
          else
              echo "‚ùå MongoDB failed to start"
              sudo systemctl status mongod --no-pager
              exit 1
          fi
          
          echo ""
          echo "üîÑ Restarting application..."
          sudo systemctl restart blog-app
          
          echo "‚è≥ Waiting for application to start (10 seconds)..."
          sleep 10
          
          if ! sudo systemctl is-active --quiet blog-app; then
              echo "‚ùå Application failed to start"
              echo ""
              echo "=== Service Status ==="
              sudo systemctl status blog-app --no-pager -l || true
              echo ""
              echo "=== Recent Logs ==="
              sudo journalctl -u blog-app -n 30 --no-pager || true
              exit 1
          fi
          
          echo "‚úÖ Application service is running"
          
          echo ""
          echo "üè• Performing health checks..."
          HEALTH_CHECK_PASSED=false
          
          for i in 1 2 3 4 5; do
              echo "Health check attempt \$i/5..."
              
              if curl -f -s http://localhost:5000/health > /dev/null 2>&1; then
                  HEALTH_RESPONSE=\$(curl -s http://localhost:5000/health)
                  echo "‚úÖ Health endpoint responding: \$HEALTH_RESPONSE"
                  HEALTH_CHECK_PASSED=true
                  break
              else
                  if [ \$i -lt 5 ]; then
                      echo "‚ö†Ô∏è  Health check failed, retrying in 3 seconds..."
                      sleep 3
                  fi
              fi
          done
          
          if [ "\$HEALTH_CHECK_PASSED" = false ]; then
              echo "‚ùå Health check failed after 5 attempts"
              echo ""
              echo "=== Application Logs ==="
              sudo journalctl -u blog-app -n 30 --no-pager
              echo ""
              echo "=== Error Logs ==="
              tail -20 logs/error.log 2>/dev/null || echo "No error log found"
              exit 1
          fi
          
          echo ""
          echo "Testing metrics endpoint..."
          if curl -f -s http://localhost:5000/metrics | grep -q "blog_"; then
              echo "‚úÖ Metrics endpoint responding with blog metrics"
          else
              echo "‚ö†Ô∏è  Metrics endpoint may have issues (non-critical)"
          fi
          
          echo ""
          echo "Testing main application page..."
          if curl -f -s http://localhost:5000/ | grep -q "<!DOCTYPE html>"; then
              echo "‚úÖ Main page responding with HTML"
          else
              echo "‚ö†Ô∏è  Main page may have issues"
          fi
          
          echo ""
          echo "=== Deployment Summary ==="
          echo "‚úÖ Code updated to latest commit"
          echo "‚úÖ Dependencies installed"
          echo "‚úÖ Environment configured"
          echo "‚úÖ Application restarted"
          echo "‚úÖ All health checks passed"
          echo ""
          echo "üéâ Deployment successful to Droplet 1!"
          echo "Timestamp: \$(date)"
          ENDSSH
      
      - name: Verify deployment
        env:
          HOST: ${{ secrets.DIGITALOCEAN_HOST }}
          USER: ${{ secrets.DIGITALOCEAN_USER }}
        run: |
          echo ""
          echo "=== Final Verification ==="
          
          echo "Waiting 5 seconds before verification..."
          sleep 5
          
          echo "Testing external access..."
          
          for attempt in 1 2 3; do
            echo "Verification attempt $attempt/3..."
            
            if ssh -o ConnectTimeout=30 -o ServerAliveInterval=10 $USER@$HOST "bash -s" <<'VERIFY'
          if curl -f -s http://localhost:5000/health > /dev/null; then
              echo "‚úÖ Health endpoint accessible"
          else
              echo "‚ùå Health endpoint not accessible"
              exit 1
          fi
          
          if systemctl is-active --quiet blog-app; then
              echo "‚úÖ Application service is active"
          else
              echo "‚ùå Application service is not active"
              exit 1
          fi
          
          if systemctl is-active --quiet mongod; then
              echo "‚úÖ MongoDB service is active"
          else
              echo "‚ùå MongoDB service is not active"
              exit 1
          fi
          VERIFY
            then
              echo "‚úÖ Verification successful!"
              exit 0
            else
              echo "‚ö†Ô∏è Attempt $attempt failed, retrying in 5 seconds..."
              sleep 5
            fi
          done
          
          echo "‚ùå Verification failed after 3 attempts"
          exit 1

  notify:
    name: Deployment Notification
    needs: deploy
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Notify deployment status
        run: |
          echo "=== Deployment Status ==="
          echo "Status: ${{ needs.deploy.result }}"
          echo "GitHub Run: #${{ github.run_number }}"
          echo "Commit: ${{ github.sha }}"
          echo "Branch: ${{ github.ref }}"
          echo "Actor: ${{ github.actor }}"
          echo ""
          
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "‚úÖ Deployment to Droplet 1 was successful!"
            echo ""
            echo "üìä Build Information:"
            echo "  Run: #${{ github.run_number }}"
            echo "  Commit: ${{ github.sha }}"
            echo "  Time: $(date)"
          else
            echo "‚ùå Deployment to Droplet 1 failed!"
            echo ""
            echo "Please check the deployment logs above for details."
            echo ""
            echo "Common issues:"
            echo "  - SSH connection problems - Check DIGITALOCEAN_SSH_KEY secret"
            echo "  - MongoDB not running - Run: sudo systemctl start mongod"
            echo "  - Application startup errors - Check: sudo journalctl -u blog-app"
            echo "  - Health check failures - Verify .env file is correct"
            echo ""
            exit 1
          fi