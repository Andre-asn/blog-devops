name: CI/CD Pipeline - Droplet 1

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  VERSION_MAJOR: '1'
  VERSION_MINOR: '0'

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    
    services:
      mongodb:
        image: mongo:7.0
        ports:
          - 27017:27017
        options: >-
          --health-cmd "mongosh --eval 'db.runCommand({ ping: 1 })'"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'
      
      - name: Cache pip dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          echo "Installed packages:"
          pip list | grep -E "Flask|pymongo|pytest|gunicorn|prometheus"
      
      - name: Wait for MongoDB
        run: |
          echo "Waiting for MongoDB to be ready..."
          python3 << 'EOF'
          import time
          from pymongo import MongoClient
          from pymongo.errors import ConnectionFailure

          for i in range(30):
              try:
                  client = MongoClient("mongodb://localhost:27017/", serverSelectionTimeoutMS=2000)
                  client.admin.command('ping')
                  print("‚úÖ MongoDB is ready")
                  exit(0)
              except ConnectionFailure:
                  print(f"Waiting... ({i+1}/30)")
                  time.sleep(2)
          
          print("‚ùå MongoDB failed to become ready")
          exit(1)
          EOF
      
      - name: Run tests
        env:
          MONGO_URI: mongodb://localhost:27017/
          SECRET_KEY: test-secret-key-for-ci-${{ github.run_number }}
          FLASK_ENV: testing
        run: |
          echo "Running pytest with coverage..."
          pytest -v \
            --cov=. \
            --cov-report=xml \
            --cov-report=html \
            --cov-report=term \
            --tb=short
          
          echo ""
          echo "=== Test Summary ==="
          echo "‚úÖ Tests completed"
      
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          files: ./coverage.xml
          fail_ci_if_error: false
          verbose: true
      
      - name: Upload coverage reports as artifact
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: coverage-report
          path: htmlcov/
          retention-days: 30
      
      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results
          path: |
            test-results.xml
            htmlcov/
          retention-days: 30

  generate-documentation:
    name: Generate Pyreverse Documentation
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
      
      - name: Pull latest changes
        run: |
          echo "=== Syncing with remote before documentation generation ==="
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          echo "Fetching latest changes from origin/main..."
          git fetch origin main
          
          echo "Current commit: $(git rev-parse HEAD)"
          echo "Remote commit: $(git rev-parse origin/main)"
          
          BEHIND=$(git rev-list HEAD..origin/main --count)
          if [ "$BEHIND" -gt 0 ]; then
            echo "‚ö†Ô∏è  Local branch is $BEHIND commit(s) behind remote"
            echo "Pulling latest changes..."
            git pull origin main --rebase --autostash
            echo "‚úÖ Successfully synced with remote"
          else
            echo "‚úÖ Already up to date with remote"
          fi
          
          echo "Final commit: $(git rev-parse HEAD)"
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      
      - name: Install Pylint and Graphviz
        run: |
          python -m pip install --upgrade pip
          pip install pylint
          sudo apt-get update
          sudo apt-get install -y graphviz
          
          echo "Pylint version:"
          pylint --version
          
          echo ""
          echo "Graphviz version:"
          dot -V
      
      - name: Create documentation directory
        run: |
          mkdir -p documentations/actions-doc
          echo "‚úÖ Created documentations/actions-doc directory"
      
      - name: Find Python files
        id: find-python
        run: |
          echo "=== Finding Python files ==="
          
          PYTHON_FILES=$(find . -name "*.py" \
            -not -path "./venv/*" \
            -not -path "./.venv/*" \
            -not -path "./__pycache__/*" \
            -not -path "./tests/*" \
            -not -path "./.git/*" \
            -not -path "./htmlcov/*" \
            -not -name "conftest.py" \
            -not -name "test_*.py" \
            | tr '\n' ' ')
          
          echo "Python files found:"
          echo "$PYTHON_FILES" | tr ' ' '\n' | grep -v "^$" | sed 's/^/  ‚Ä¢ /'
          
          echo "python_files=$PYTHON_FILES" >> $GITHUB_OUTPUT
      
      - name: Generate Pyreverse UML diagrams
        run: |
          echo "=== Running Pyreverse ==="
          
          PYTHON_FILES="${{ steps.find-python.outputs.python_files }}"
          
          if [ -z "$PYTHON_FILES" ]; then
            echo "‚ö†Ô∏è No Python files found to analyze"
            exit 0
          fi
          
          echo "Generating UML diagrams..."
          pyreverse -o dot -p blog_app $PYTHON_FILES -d documentations/actions-doc 2>/dev/null || true
          
          echo ""
          echo "Generated .dot files:"
          ls -la documentations/actions-doc/*.dot 2>/dev/null || echo "  No .dot files generated"
      
      - name: Convert to PNG and SVG
        run: |
          echo "=== Converting diagrams to PNG and SVG ==="
          
          for dotfile in documentations/actions-doc/*.dot; do
            if [ -f "$dotfile" ]; then
              basename=$(basename "$dotfile" .dot)
              echo "Converting $basename..."
              
              dot -Tpng "$dotfile" -o "documentations/actions-doc/${basename}.png" && \
                echo "  ‚úÖ ${basename}.png" || echo "  ‚ö†Ô∏è Failed to generate ${basename}.png"
              
              dot -Tsvg "$dotfile" -o "documentations/actions-doc/${basename}.svg" && \
                echo "  ‚úÖ ${basename}.svg" || echo "  ‚ö†Ô∏è Failed to generate ${basename}.svg"
            fi
          done
      
      - name: Generate Documentation README
        env:
          GITHUB_RUN_NUMBER: ${{ github.run_number }}
          GITHUB_SHA: ${{ github.sha }}
        run: |
          cat > documentations/actions-doc/README.md << 'READMEEOF'
          # GitHub Actions - Code Documentation

          This documentation is automatically generated by the GitHub Actions CI/CD pipeline using Pyreverse.

          ## Generated Files

          ### UML Diagrams

          | File | Description |
          |------|-------------|
          | classes_blog_app.dot | Class diagram in DOT format |
          | classes_blog_app.png | Class diagram as PNG image |
          | classes_blog_app.svg | Class diagram as SVG (scalable) |
          | packages_blog_app.dot | Package diagram in DOT format |
          | packages_blog_app.png | Package diagram as PNG image |
          | packages_blog_app.svg | Package diagram as SVG (scalable) |

          ### Class Diagram
          Shows the classes in the application, their attributes, methods, and relationships.

          ![Class Diagram](classes_blog_app.png)

          ### Package Diagram
          Shows the package/module structure and dependencies.

          ![Package Diagram](packages_blog_app.png)

          ## Generation Details

          - **Generated by**: GitHub Actions
          - **Tool**: Pyreverse (part of Pylint)
          - **Visualization**: Graphviz

          ## How to Regenerate

          These diagrams are automatically regenerated on each successful push to main branch.

          To manually regenerate:

          1. Install dependencies: pip install pylint
          2. Install Graphviz: sudo apt-get install graphviz
          3. Generate dot files: pyreverse -o dot -p blog_app *.py
          4. Convert to images: dot -Tpng classes_blog_app.dot -o classes_blog_app.png

          ## Last Updated
          READMEEOF
          
          echo "" >> documentations/actions-doc/README.md
          echo "**Timestamp**: $(date -u)" >> documentations/actions-doc/README.md
          echo "" >> documentations/actions-doc/README.md
          echo "**GitHub Run**: #${GITHUB_RUN_NUMBER}" >> documentations/actions-doc/README.md
          echo "" >> documentations/actions-doc/README.md
          echo "**Commit**: ${GITHUB_SHA}" >> documentations/actions-doc/README.md
      
      - name: List generated files
        run: |
          echo "=== Documentation Generated ==="
          echo "Contents of documentations/actions-doc:"
          ls -la documentations/actions-doc/ | sed 's/^/  /'
      
      - name: Upload documentation as artifact
        uses: actions/upload-artifact@v4
        with:
          name: pyreverse-documentation
          path: documentations/actions-doc/
          retention-days: 30
      
      - name: Commit and push documentation with retry
        env:
          MAX_RETRIES: 5
          RETRY_DELAY: 10
        run: |
          echo "=== Committing Documentation with Retry Logic ==="
          
          attempt_push() {
            local attempt=$1
            echo ""
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "Attempt $attempt of $MAX_RETRIES"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            
            echo "Fetching latest from origin/main..."
            git fetch origin main
            
            LOCAL_COMMIT=$(git rev-parse HEAD)
            REMOTE_COMMIT=$(git rev-parse origin/main)
            
            echo "Local commit:  $LOCAL_COMMIT"
            echo "Remote commit: $REMOTE_COMMIT"
            
            if [ "$LOCAL_COMMIT" != "$REMOTE_COMMIT" ]; then
              BEHIND=$(git rev-list HEAD..origin/main --count)
              echo "‚ö†Ô∏è  Local is $BEHIND commit(s) behind remote"
              
              echo "Rebasing onto origin/main..."
              if git rebase origin/main; then
                echo "‚úÖ Rebase successful"
              else
                echo "‚ö†Ô∏è  Rebase had conflicts, attempting to resolve..."
                
                CONFLICTS=$(git diff --name-only --diff-filter=U)
                echo "Conflicts in: $CONFLICTS"
                
                if echo "$CONFLICTS" | grep -q "documentations/actions-doc/"; then
                  echo "Conflict in actions-doc, using our version..."
                  git checkout --ours documentations/actions-doc/
                  git add documentations/actions-doc/
                  git rebase --continue
                else
                  echo "Conflicts outside our documentation path, aborting..."
                  git rebase --abort
                  return 1
                fi
              fi
            else
              echo "‚úÖ Already up to date with remote"
            fi
            
            git add documentations/actions-doc/
            
            if git diff --cached --quiet; then
              echo "‚ÑπÔ∏è  No changes to documentation - skipping commit"
              return 0
            fi
            
            echo "Committing documentation changes..."
            git commit -m "docs(actions): Update Pyreverse UML documentation [Run #${{ github.run_number }}]

          Generated by GitHub Actions
          - Class diagrams
          - Package diagrams  
          - PNG and SVG formats

          [skip ci]"
            
            echo "Pushing to repository..."
            if git push origin HEAD:main; then
              echo "‚úÖ Successfully pushed documentation"
              return 0
            else
              echo "‚ùå Push failed"
              return 1
            fi
          }
          
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          SUCCESS=false
          for i in $(seq 1 $MAX_RETRIES); do
            if attempt_push $i; then
              SUCCESS=true
              break
            else
              if [ $i -lt $MAX_RETRIES ]; then
                echo ""
                echo "‚è≥ Waiting ${RETRY_DELAY} seconds before retry..."
                sleep $RETRY_DELAY
              fi
            fi
          done
          
          if [ "$SUCCESS" = true ]; then
            echo ""
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "‚úÖ Documentation successfully committed and pushed"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          else
            echo ""
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "‚ùå Failed to push documentation after $MAX_RETRIES attempts"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo ""
            echo "This is not critical - documentation artifacts are still available"
            echo "Manual intervention may be needed to commit documentation"
            exit 0
          fi

  generate-artifact:
    name: Generate Deployment Artifact
    needs: [test, generate-documentation]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    outputs:
      version: ${{ steps.version.outputs.version }}
      artifact_name: ${{ steps.version.outputs.artifact_name }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
      
      - name: Pull latest changes
        run: |
          echo "=== Syncing with remote before artifact generation ==="
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git fetch origin main
          git pull origin main --rebase --autostash || git reset --hard origin/main
          
          echo "Current commit: $(git rev-parse HEAD)"
      
      - name: Calculate version
        id: version
        run: |
          # Get truncated commit hash (7 characters)
          COMMIT_HASH=$(git rev-parse --short=7 HEAD)
          VERSION="${{ env.VERSION_MAJOR }}.${{ env.VERSION_MINOR }}.${{ github.run_number }}"
          ARTIFACT_NAME="blog-app-${COMMIT_HASH}"
          
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "artifact_name=${ARTIFACT_NAME}" >> $GITHUB_OUTPUT
          echo "commit_hash=${COMMIT_HASH}" >> $GITHUB_OUTPUT
          
          echo "=== Version Information ==="
          echo "Version: ${VERSION}"
          echo "Commit Hash: ${COMMIT_HASH}"
          echo "Artifact Name: ${ARTIFACT_NAME}"
      
      - name: Create artifact directory
        run: |
          mkdir -p artifacts/actions
          mkdir -p temp_artifact
          echo "‚úÖ Created artifact directories"
      
      - name: Collect application files
        run: |
          echo "=== Collecting Application Files ==="
          
          # Copy Python files
          echo "Copying Python source files..."
          find . -name "*.py" \
            -not -path "./venv/*" \
            -not -path "./.venv/*" \
            -not -path "./__pycache__/*" \
            -not -path "./.git/*" \
            -not -path "./htmlcov/*" \
            -not -path "./artifacts/*" \
            -not -path "./temp_artifact/*" \
            -exec cp --parents {} temp_artifact/ \;
          
          # Copy templates
          if [ -d "templates" ]; then
            echo "Copying templates..."
            cp -r templates temp_artifact/
          fi
          
          # Copy static files
          if [ -d "static" ]; then
            echo "Copying static files..."
            cp -r static temp_artifact/
          fi
          
          # Copy requirements
          if [ -f "requirements.txt" ]; then
            echo "Copying requirements.txt..."
            cp requirements.txt temp_artifact/
          fi
          
          # Copy configuration files
          for config_file in .pylintrc pytest.ini setup.py setup.cfg pyproject.toml; do
            if [ -f "$config_file" ]; then
              echo "Copying $config_file..."
              cp "$config_file" temp_artifact/
            fi
          done
          
          echo "‚úÖ Application files collected"
      
      - name: Generate VERSION file
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          echo "Generating VERSION file..."
          cat > temp_artifact/VERSION << EOF
          {
              "version": "${VERSION}",
              "major": ${{ env.VERSION_MAJOR }},
              "minor": ${{ env.VERSION_MINOR }},
              "build": ${{ github.run_number }},
              "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
              "git_commit": "${{ github.sha }}",
              "git_branch": "main",
              "built_by": "GitHub Actions",
              "workflow": "${{ github.workflow }}",
              "run_id": "${{ github.run_id }}"
          }
          EOF
          
          echo "‚úÖ VERSION file generated"
          cat temp_artifact/VERSION
      
      - name: Generate MANIFEST file
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          echo "Generating MANIFEST file..."
          cat > temp_artifact/MANIFEST << EOF
          Blog Application Deployment Artifact
          =====================================

          Version: ${VERSION}
          Build Number: ${{ github.run_number }}
          Build Date: $(date -u)
          Git Commit: ${{ github.sha }}
          Git Branch: main
          Workflow: ${{ github.workflow }}
          Run ID: ${{ github.run_id }}

          Contents:
          ---------
          EOF
          
          # List contents for manifest
          (cd temp_artifact && find . -type f | sort | sed 's/^/  /') >> temp_artifact/MANIFEST
          
          echo "‚úÖ MANIFEST file generated"
      
      - name: Create ZIP artifact
        env:
          VERSION: ${{ steps.version.outputs.version }}
          ARTIFACT_NAME: ${{ steps.version.outputs.artifact_name }}
        run: |
          echo "=== Creating ZIP Artifact ==="
          
          cd temp_artifact
          zip -r "../artifacts/actions/${ARTIFACT_NAME}.zip" .
          cd ..
          
          echo "‚úÖ ZIP artifact created"
          ls -lh "artifacts/actions/${ARTIFACT_NAME}.zip"
      
      - name: Generate artifact README
        env:
          VERSION: ${{ steps.version.outputs.version }}
          ARTIFACT_NAME: ${{ steps.version.outputs.artifact_name }}
        run: |
          echo "Generating artifact README..."
          cat > artifacts/actions/README.md << 'READMEEOF'
          # GitHub Actions - Deployment Artifacts

          This directory contains deployment-ready artifacts generated by the GitHub Actions CI/CD pipeline.

          ## Versioning Scheme
          
          Artifacts are named using the commit hash: `blog-app-<commit-hash>`
          
          - **Commit Hash**: Truncated 7-character Git commit hash (e.g., `feb3464`)
          - The VERSION file inside the artifact still contains semantic versioning (`major.minor.changelist`)
          - This allows easy identification of which commit the artifact represents

          ## Artifact Contents

          The ZIP artifact contains:
          - Python source files (*.py)
          - Templates (templates/)
          - Static files (static/)
          - Requirements (requirements.txt)
          - Configuration files
          - VERSION file (JSON metadata)
          - MANIFEST file (contents listing)

          ## How to Deploy

          1. Download the artifact ZIP file
          2. Extract to your deployment directory
          3. Create virtual environment: `python3 -m venv venv`
          4. Activate: `source venv/bin/activate`
          5. Install dependencies: `pip install -r requirements.txt`
          6. Configure environment variables
          7. Start the application

          ## Available Artifacts

          READMEEOF
          
          echo "" >> artifacts/actions/README.md
          echo "| Version | Filename | Size | Date |" >> artifacts/actions/README.md
          echo "|---------|----------|------|------|" >> artifacts/actions/README.md
          
          for artifact in artifacts/actions/*.zip; do
            if [ -f "$artifact" ]; then
              artifact_file=$(basename "$artifact")
              artifact_size=$(du -h "$artifact" | cut -f1)
              artifact_ver=$(echo "$artifact_file" | sed 's/blog-app-\(.*\)\.zip/\1/')
              echo "| ${artifact_ver} | ${artifact_file} | ${artifact_size} | $(date -u +%Y-%m-%d) |" >> artifacts/actions/README.md
            fi
          done
          
          echo "" >> artifacts/actions/README.md
          echo "## Current Build" >> artifacts/actions/README.md
          echo "" >> artifacts/actions/README.md
          echo "| Property | Value |" >> artifacts/actions/README.md
          echo "|----------|-------|" >> artifacts/actions/README.md
          COMMIT_HASH=$(git rev-parse --short=7 HEAD)
          echo "| Version | ${VERSION} |" >> artifacts/actions/README.md
          echo "| Filename | ${ARTIFACT_NAME}.zip |" >> artifacts/actions/README.md
          echo "| Commit Hash | ${COMMIT_HASH} |" >> artifacts/actions/README.md
          echo "| GitHub Run | #${{ github.run_number }} |" >> artifacts/actions/README.md
          echo "| Full Commit | ${{ github.sha }} |" >> artifacts/actions/README.md
          echo "| Timestamp | $(date -u) |" >> artifacts/actions/README.md
          
          echo "‚úÖ README generated"
      
      - name: Clean up temp directory
        run: rm -rf temp_artifact
      
      - name: Upload artifact to GitHub
        uses: actions/upload-artifact@v4
        with:
          name: deployment-artifact-${{ steps.version.outputs.version }}
          path: artifacts/actions/${{ steps.version.outputs.artifact_name }}.zip
          retention-days: 90
      
      - name: List artifact directory
        run: |
          echo "=== Artifact Directory Contents ==="
          ls -la artifacts/actions/
      
      - name: Commit and push artifact with retry
        env:
          MAX_RETRIES: 5
          RETRY_DELAY: 10
          VERSION: ${{ steps.version.outputs.version }}
          ARTIFACT_NAME: ${{ steps.version.outputs.artifact_name }}
        run: |
          echo "=== Committing Artifact with Retry Logic ==="
          
          attempt_push() {
            local attempt=$1
            echo ""
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "Attempt $attempt of $MAX_RETRIES"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            
            echo "Fetching latest from origin/main..."
            git fetch origin main
            
            LOCAL_COMMIT=$(git rev-parse HEAD)
            REMOTE_COMMIT=$(git rev-parse origin/main)
            
            echo "Local commit:  $LOCAL_COMMIT"
            echo "Remote commit: $REMOTE_COMMIT"
            
            if [ "$LOCAL_COMMIT" != "$REMOTE_COMMIT" ]; then
              BEHIND=$(git rev-list HEAD..origin/main --count)
              echo "‚ö†Ô∏è  Local is $BEHIND commit(s) behind remote"
              
              echo "Rebasing onto origin/main..."
              if git rebase origin/main; then
                echo "‚úÖ Rebase successful"
              else
                echo "‚ö†Ô∏è  Rebase had conflicts, attempting to resolve..."
                
                CONFLICTS=$(git diff --name-only --diff-filter=U)
                echo "Conflicts in: $CONFLICTS"
                
                if echo "$CONFLICTS" | grep -q "artifacts/actions/"; then
                  echo "Conflict in artifacts/actions, using our version..."
                  git checkout --ours artifacts/actions/
                  git add artifacts/actions/
                  git rebase --continue || git rebase --skip
                else
                  echo "Conflicts outside our artifact path, aborting..."
                  git rebase --abort
                  return 1
                fi
              fi
            else
              echo "‚úÖ Already up to date with remote"
            fi
            
            git add artifacts/actions/
            
            if git diff --cached --quiet; then
              echo "‚ÑπÔ∏è  No changes to commit - skipping"
              return 0
            fi
            
            echo "Committing artifact..."
            COMMIT_HASH=$(git rev-parse --short=7 HEAD)
            git commit -m "build(actions): Add deployment artifact for commit ${COMMIT_HASH} [Run #${{ github.run_number }}]" -m "Generated by GitHub Actions:" -m "- Artifact: ${ARTIFACT_NAME}.zip" -m "- Commit Hash: ${COMMIT_HASH}" -m "- Version: ${VERSION}" -m "- Full Commit: ${{ github.sha }}" -m "[skip ci]"
            
            echo "Pushing to repository..."
            if git push origin HEAD:main; then
              echo "‚úÖ Successfully pushed artifact"
              return 0
            else
              echo "‚ùå Push failed"
              return 1
            fi
          }
          
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          SUCCESS=false
          for i in $(seq 1 $MAX_RETRIES); do
            if attempt_push $i; then
              SUCCESS=true
              break
            else
              if [ $i -lt $MAX_RETRIES ]; then
                echo ""
                echo "‚è≥ Waiting ${RETRY_DELAY} seconds before retry..."
                sleep $RETRY_DELAY
              fi
            fi
          done
          
          if [ "$SUCCESS" = true ]; then
            echo ""
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "‚úÖ Artifact successfully committed and pushed"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo ""
            echo "Artifact: ${ARTIFACT_NAME}.zip"
            echo "Version: ${VERSION}"
            echo "Location: artifacts/actions/"
          else
            echo ""
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "‚ö†Ô∏è  Failed to push artifact after $MAX_RETRIES attempts"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo ""
            echo "Artifact is still available as GitHub Actions artifact"
            exit 0
          fi

  deploy:
    name: Deploy to Droplet 1
    needs: [test, generate-documentation, generate-artifact]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 1
      
      - name: Sync with latest main
        run: |
          git pull origin main
      
      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.DIGITALOCEAN_SSH_KEY }}
      
      - name: Add server to known hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.DIGITALOCEAN_HOST }} >> ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts
      
      - name: Test SSH connection
        env:
          HOST: ${{ secrets.DIGITALOCEAN_HOST }}
          USER: ${{ secrets.DIGITALOCEAN_USER }}
        run: |
          echo "Testing SSH connection to $HOST..."
          ssh -o ConnectTimeout=10 $USER@$HOST 'echo "‚úÖ SSH connection successful"'
      
      - name: Deploy to DigitalOcean Droplet 1
        env:
          HOST: ${{ secrets.DIGITALOCEAN_HOST }}
          USER: ${{ secrets.DIGITALOCEAN_USER }}
          APP_DIR: ${{ secrets.APP_DIRECTORY }}
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
          MONGO_URI: ${{ secrets.MONGO_URI }}
          DATABASE_NAME: ${{ secrets.DATABASE_NAME }}
          GITHUB_RUN: ${{ github.run_number }}
          VERSION: ${{ needs.generate-artifact.outputs.version }}
        run: |
          echo "=== Starting Deployment to Droplet 1 ==="
          echo "Host: $HOST"
          echo "User: $USER"
          echo "App Directory: $APP_DIR"
          echo "GitHub Run: #$GITHUB_RUN"
          echo "Version: $VERSION"
          echo ""
          
          ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 $USER@$HOST "bash -s" <<ENDSSH
          set -e
          
          echo "=== Deployment Started ==="
          echo "Timestamp: \$(date)"
          echo ""
          
          cd ${APP_DIR}
          echo "‚úÖ In directory: \$(pwd)"
          
          echo "Current branch: \$(git branch --show-current)"
          
          echo ""
          echo "üßπ Cleaning local repository..."
          git reset --hard HEAD
          git clean -fd
          
          echo ""
          echo "üì• Fetching latest code from remote..."
          git fetch origin main
          
          echo ""
          echo "üîÑ Resetting to origin/main..."
          git reset --hard origin/main
          
          echo "Latest commit: \$(git log -1 --oneline)"
          
          echo ""
          echo "üêç Activating virtual environment..."
          if [ ! -d "venv" ]; then
              echo "‚ö†Ô∏è  Virtual environment not found, creating..."
              python3 -m venv venv
          fi
          source venv/bin/activate
          
          echo "Python: \$(which python3)"
          echo "Pip: \$(which pip)"
          
          echo ""
          echo "üì¶ Installing/updating dependencies..."
          pip install --upgrade pip
          pip install -r requirements.txt
          
          echo "Verifying critical packages:"
          pip show Flask pymongo gunicorn prometheus-client | grep -E "Name|Version" || true
          
          echo ""
          echo "‚öôÔ∏è  Updating environment variables..."
          echo "SECRET_KEY=${SECRET_KEY}" > .env
          echo "MONGO_URI=${MONGO_URI}" >> .env
          echo "DATABASE_NAME=${DATABASE_NAME}" >> .env
          echo "FLASK_ENV=production" >> .env
          echo "FLASK_DEBUG=False" >> .env
          chmod 600 .env
          echo "‚úÖ Environment file updated"
          
          echo ""
          echo "üìù Setting up logs directory..."
          mkdir -p logs
          chmod 755 logs
          echo "‚úÖ Logs directory ready"
          
          deactivate
          
          echo ""
          echo "üîç Pre-deployment checks..."
          
          if ! systemctl list-unit-files | grep -q "blog-app.service"; then
              echo "‚ùå blog-app.service not found"
              echo "Please run the setup script first"
              exit 1
          fi
          echo "‚úÖ Service file exists"
          
          if ! systemctl is-active --quiet mongod; then
              echo "‚ö†Ô∏è  MongoDB not running, attempting to start..."
              sudo systemctl start mongod
              sleep 3
          fi
          
          if systemctl is-active --quiet mongod; then
              echo "‚úÖ MongoDB is running"
          else
              echo "‚ùå MongoDB failed to start"
              sudo systemctl status mongod --no-pager
              exit 1
          fi
          
          echo ""
          echo "üîÑ Restarting application..."
          sudo systemctl restart blog-app
          
          echo "‚è≥ Waiting for application to start (10 seconds)..."
          sleep 10
          
          if ! sudo systemctl is-active --quiet blog-app; then
              echo "‚ùå Application failed to start"
              echo ""
              echo "=== Service Status ==="
              sudo systemctl status blog-app --no-pager -l || true
              echo ""
              echo "=== Recent Logs ==="
              sudo journalctl -u blog-app -n 30 --no-pager || true
              exit 1
          fi
          
          echo "‚úÖ Application service is running"
          
          echo ""
          echo "üè• Performing health checks..."
          HEALTH_CHECK_PASSED=false
          
          for i in {1..5}; do
              echo "Health check attempt \$i/5..."
              
              if curl -f -s http://localhost:5000/health > /dev/null 2>&1; then
                  HEALTH_RESPONSE=\$(curl -s http://localhost:5000/health)
                  echo "‚úÖ Health endpoint responding: \$HEALTH_RESPONSE"
                  HEALTH_CHECK_PASSED=true
                  break
              else
                  if [ \$i -lt 5 ]; then
                      echo "‚ö†Ô∏è  Health check failed, retrying in 3 seconds..."
                      sleep 3
                  fi
              fi
          done
          
          if [ "\$HEALTH_CHECK_PASSED" = false ]; then
              echo "‚ùå Health check failed after 5 attempts"
              echo ""
              echo "=== Application Logs ==="
              sudo journalctl -u blog-app -n 30 --no-pager
              echo ""
              echo "=== Error Logs ==="
              tail -20 logs/error.log 2>/dev/null || echo "No error log found"
              exit 1
          fi
          
          echo ""
          echo "Testing metrics endpoint..."
          if curl -f -s http://localhost:5000/metrics | grep -q "blog_"; then
              echo "‚úÖ Metrics endpoint responding with blog metrics"
          else
              echo "‚ö†Ô∏è  Metrics endpoint may have issues (non-critical)"
          fi
          
          echo ""
          echo "Testing main application page..."
          if curl -f -s http://localhost:5000/ | grep -q "<!DOCTYPE html>"; then
              echo "‚úÖ Main page responding with HTML"
          else
              echo "‚ö†Ô∏è  Main page may have issues"
          fi
          
          echo ""
          echo "=== Deployment Summary ==="
          echo "‚úÖ Code updated to latest commit"
          echo "‚úÖ Dependencies installed"
          echo "‚úÖ Environment configured"
          echo "‚úÖ Application restarted"
          echo "‚úÖ All health checks passed"
          echo ""
          echo "üéâ Deployment successful to Droplet 1!"
          echo "Timestamp: \$(date)"
          ENDSSH
      
      - name: Verify deployment
        env:
          HOST: ${{ secrets.DIGITALOCEAN_HOST }}
          USER: ${{ secrets.DIGITALOCEAN_USER }}
        run: |
          echo ""
          echo "=== Final Verification ==="
          
          echo "Testing external access..."
          
          ssh $USER@$HOST "bash -s" <<'VERIFY'
          if curl -f -s http://localhost:5000/health > /dev/null; then
              echo "‚úÖ Health endpoint accessible"
          else
              echo "‚ùå Health endpoint not accessible"
              exit 1
          fi
          
          if systemctl is-active --quiet blog-app; then
              echo "‚úÖ Application service is active"
          else
              echo "‚ùå Application service is not active"
              exit 1
          fi
          
          if systemctl is-active --quiet mongod; then
              echo "‚úÖ MongoDB service is active"
          else
              echo "‚ùå MongoDB service is not active"
              exit 1
          fi
          VERIFY
          
          echo ""
          echo "‚úÖ All verification checks passed!"

  notify:
    name: Deployment Notification
    needs: [deploy, generate-artifact]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Notify deployment status
        run: |
          echo "=== Deployment Status ==="
          echo "Status: ${{ needs.deploy.result }}"
          echo "Version: ${{ needs.generate-artifact.outputs.version }}"
          echo "GitHub Run: #${{ github.run_number }}"
          echo "Commit: ${{ github.sha }}"
          echo "Branch: ${{ github.ref }}"
          echo "Actor: ${{ github.actor }}"
          echo ""
          
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "‚úÖ Deployment to Droplet 1 was successful!"
            echo ""
            echo "üìä Build Information:"
            echo "  Version: ${{ needs.generate-artifact.outputs.version }}"
            echo "  Run: #${{ github.run_number }}"
            echo "  Commit: ${{ github.sha }}"
            echo "  Time: $(date)"
            echo ""
            echo "üì¶ Artifact: ${{ needs.generate-artifact.outputs.artifact_name }}.zip"
          else
            echo "‚ùå Deployment to Droplet 1 failed!"
            echo ""
            echo "Please check the deployment logs above for details."
            echo ""
            echo "Common issues:"
            echo "  ‚Ä¢ SSH connection problems - Check DIGITALOCEAN_SSH_KEY secret"
            echo "  ‚Ä¢ MongoDB not running - Run: sudo systemctl start mongod"
            echo "  ‚Ä¢ Application startup errors - Check: sudo journalctl -u blog-app"
            echo "  ‚Ä¢ Health check failures - Verify .env file is correct"
            echo ""
            exit 1
          fi